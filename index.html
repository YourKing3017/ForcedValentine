<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine?</title>
  <style>
    :root {
      --bg: #fff5f7;
      --text: #111;
      --yes: #22c55e;
      --no:  #f43f5e;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      overflow: hidden;
    }
    .wrap {
      position: relative;
      width: 100vw;
      height: 100vh;
      user-select: none;
    }
    h1 {
      position: absolute;
      top: 42px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 28px;
      font-weight: 800;
      color: var(--text);
      text-align: center;
      white-space: nowrap;
    }
    #result {
      position: absolute;
      bottom: 28px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 16px;
      color: var(--text);
    }

    /* Capsule buttons */
    .btn {
      position: absolute;
      width: 140px;
      height: 56px;
      border: none;
      border-radius: 999px;
      color: #fff;
      font-weight: 800;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 1px 0 rgba(0,0,0,.15);
      transition: transform 60ms linear;
      will-change: transform, left, top, width, height;
    }
    .btn:active { filter: brightness(.9); transform: translateY(1px); }
    #yes { background: var(--yes); }
    #no  { background: var(--no);  }

    /* Keep hitbox aligned with visual size */
    .btn-inner {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
    }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <h1>Will you be my valentine?</h1>

    <button class="btn" id="yes"><span class="btn-inner">Yes</span></button>
    <button class="btn" id="no"><span class="btn-inner">No</span></button>

    <div id="result">&nbsp;</div>
  </div>

  <script>
    const wrap = document.getElementById('wrap');
    const yesBtn = document.getElementById('yes');
    const noBtn  = document.getElementById('no');
    const result = document.getElementById('result');

    // Base sizes/positions
    const yesBase = { w: 140, h: 56 };
    const noBase  = { w: 140, h: 56 };

    // Scale constraints (match your Java logic)
    const YES_MAX = 1.30, YES_MIN = 1.00;
    const NO_MIN  = 0.70, NO_MAX  = 1.00;

    // Interaction tuning
    const TRIGGER_DIST = 160;    // px
    const TELEPORT_DIST = 5;     // px to rect edge
    const wallZone = 80;

    // Motion
    let noVX = 0, noVY = 0;
    let lastTeleport = 0;

    // Positions (top-left)
    let yesBasePos = null; // {x,y}
    let noPos = null;      // current no button {x,y}
    let noScale = 1.0;
    let yesScale = 1.0;

    // Helpers
    const clamp = (v, mn, mx) => Math.max(mn, Math.min(mx, v));
    const hypot = (a,b) => Math.hypot(a,b);

    function layoutInitial() {
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      const centerY = Math.floor(h * 0.55);

      yesBasePos = { x: Math.floor(w/2 - 170), y: Math.floor(centerY - yesBase.h/2) };
      const noBasePos = { x: Math.floor(w/2 + 30), y: Math.floor(centerY - noBase.h/2) };

      noPos = { x: noBasePos.x, y: noBasePos.y };

      applyButton(yesBtn, yesBasePos.x, yesBasePos.y, yesBase, 1.0, true);
      applyButton(noBtn,  noPos.x,      noPos.y,      noBase,  1.0, false);
    }

    function applyButton(el, x, y, base, scale, anchorCenter) {
      const w = Math.round(base.w * scale);
      const h = Math.round(base.h * scale);

      if (anchorCenter) {
        const baseCx = x + base.w / 2;
        const baseCy = y + base.h / 2;
        x = Math.round(baseCx - w / 2);
        y = Math.round(baseCy - h / 2);
      }

      el.style.left = x + 'px';
      el.style.top  = y + 'px';
      el.style.width  = w + 'px';
      el.style.height = h + 'px';
      return { w, h, x, y };
    }

    function rectOf(x, y, w, h) {
      return { x, y, w, h, cx: x + w/2, cy: y + h/2 };
    }

    function distanceToRect(px, py, r) {
      let dx = 0;
      if (px < r.x) dx = r.x - px;
      else if (px > r.x + r.w) dx = px - (r.x + r.w);

      let dy = 0;
      if (py < r.y) dy = r.y - py;
      else if (py > r.y + r.h) dy = py - (r.y + r.h);

      return Math.hypot(dx, dy);
    }

    function computeBoundsForNo(scaledNoW, scaledNoH) {
      const margin = 14;
      const topLimit = 90;
      const bottomLimit = wrap.clientHeight - 90;

      const minX = margin;
      const maxX = wrap.clientWidth - margin - scaledNoW;
      const minY = topLimit;
      const maxY = bottomLimit - scaledNoH;

      return { minX, maxX, minY, maxY, ok: (maxX > minX && maxY > minY) };
    }

    function teleportNo(mouseX, mouseY, scaledNoW, scaledNoH, bounds, currentRect) {
      const now = performance.now();
      // cooldown = 0 (as in your code); keep a tiny guard anyway
      if (now - lastTeleport < 0) return;
      lastTeleport = now;

      let bestScore = -1e18;
      let bestX = currentRect.x, bestY = currentRect.y;

      const tries = 18;
      for (let i = 0; i < tries; i++) {
        const rx = bounds.minX + Math.random() * (bounds.maxX - bounds.minX);
        const ry = bounds.minY + Math.random() * (bounds.maxY - bounds.minY);

        const candCX = rx + scaledNoW / 2;
        const candCY = ry + scaledNoH / 2;
        const d = hypot(mouseX - candCX, mouseY - candCY);

        const wall = Math.min(
          Math.min(rx - bounds.minX, bounds.maxX - rx),
          Math.min(ry - bounds.minY, bounds.maxY - ry)
        );

        const score = d + wall * 0.35;
        if (score > bestScore) {
          bestScore = score;
          bestX = rx;
          bestY = ry;
        }
      }

      noVX = 0; noVY = 0;
      noPos.x = bestX;
      noPos.y = bestY;
      applyButton(noBtn, noPos.x, noPos.y, noBase, noScale, false);
    }

    function onMouseMove(e) {
      if (!yesBasePos || !noPos) return;

      const mouseX = e.clientX;
      const mouseY = e.clientY;

      // Current No rect (based on DOM computed size)
      const noRectDOM = noBtn.getBoundingClientRect();
      const wrapRect = wrap.getBoundingClientRect();

      const noRect = rectOf(
        noRectDOM.left - wrapRect.left,
        noRectDOM.top  - wrapRect.top,
        noRectDOM.width,
        noRectDOM.height
      );

      const dx = mouseX - (noRect.cx + wrapRect.left);
      const dy = mouseY - (noRect.cy + wrapRect.top);
      const distCenter = Math.hypot(dx, dy);

      // Scaling
      yesScale = 1.0;
      noScale = 1.0;

      if (distCenter < TRIGGER_DIST) {
        const t = (TRIGGER_DIST - distCenter) / TRIGGER_DIST; // 0..1
        yesScale = clamp(YES_MIN + (YES_MAX - YES_MIN) * t, YES_MIN, YES_MAX);
        noScale  = clamp(NO_MAX  - (NO_MAX  - NO_MIN)  * t, NO_MIN,  NO_MAX);
      }

      // Apply Yes scaling (center anchored around base)
      applyButton(yesBtn, yesBasePos.x, yesBasePos.y, yesBase, yesScale, true);

      // Apply No scaling and movement
      const scaledNoW = Math.round(noBase.w * noScale);
      const scaledNoH = Math.round(noBase.h * noScale);

      const bounds = computeBoundsForNo(scaledNoW, scaledNoH);
      if (!bounds.ok) return;

      // Teleport if mouse is within TELEPORT_DIST of the No button edge
      const edgeDist = distanceToRect(mouseX - wrapRect.left, mouseY - wrapRect.top, {
        x: noRect.x, y: noRect.y, w: noRect.w, h: noRect.h
      });

      if (edgeDist <= TELEPORT_DIST) {
        teleportNo(mouseX - wrapRect.left, mouseY - wrapRect.top, scaledNoW, scaledNoH, bounds, noRect);
        return;
      }

      // Smooth flee with wall repulsion
      let ax = 0, ay = 0;

      if (distCenter < TRIGGER_DIST) {
        const t = (TRIGGER_DIST - distCenter) / TRIGGER_DIST;
        const d = distCenter === 0 ? 1 : distCenter;
        const ux = dx / d, uy = dy / d;

        const mouseAccel = 0.9 + 2.8 * t;
        ax += -ux * mouseAccel;
        ay += -uy * mouseAccel;
      }

      // Wall repulsion
      const x = noRect.x;
      const y = noRect.y;

      const dLeft   = x - bounds.minX;
      const dRight  = bounds.maxX - x;
      const dTop    = y - bounds.minY;
      const dBottom = bounds.maxY - y;

      if (dLeft   < wallZone) ax += (wallZone - dLeft)   / wallZone * 2.6;
      if (dRight  < wallZone) ax -= (wallZone - dRight)  / wallZone * 2.6;
      if (dTop    < wallZone) ay += (wallZone - dTop)    / wallZone * 2.6;
      if (dBottom < wallZone) ay -= (wallZone - dBottom) / wallZone * 2.6;

      // Velocity + damping
      const damping = 0.86;
      const maxSpeed = 18.0;

      noVX = (noVX + ax) * damping;
      noVY = (noVY + ay) * damping;

      const speed = Math.hypot(noVX, noVY);
      if (speed > maxSpeed) {
        noVX = noVX / speed * maxSpeed;
        noVY = noVY / speed * maxSpeed;
      }

      let nx = x + noVX;
      let ny = y + noVY;

      // Clamp + mild bounce
      if (nx < bounds.minX) { nx = bounds.minX; noVX = Math.abs(noVX) * 0.5; }
      if (nx > bounds.maxX) { nx = bounds.maxX; noVX = -Math.abs(noVX) * 0.5; }
      if (ny < bounds.minY) { ny = bounds.minY; noVY = Math.abs(noVY) * 0.5; }
      if (ny > bounds.maxY) { ny = bounds.maxY; noVY = -Math.abs(noVY) * 0.5; }

      // Set new position
      noPos.x = nx;
      noPos.y = ny;

      applyButton(noBtn, noPos.x, noPos.y, noBase, noScale, false);

      // Settle when far
      if (distCenter >= TRIGGER_DIST) {
        noVX *= 0.75;
        noVY *= 0.75;
      }
    }

    // Click behavior
    yesBtn.addEventListener('click', () => result.textContent = 'Yay! Luv u 2 :D');
    noBtn.addEventListener('click',  () => result.textContent = 'Noooooo how did u click it :(');

    // Make No react if mouse enters/presses it (extra safety like your Java code)
    function forceFleeFromEvent(ev) {
      // synthesize mouse move using current cursor position when event fires
      if (ev && typeof ev.clientX === 'number') onMouseMove(ev);
    }
    noBtn.addEventListener('mouseenter', forceFleeFromEvent);
    noBtn.addEventListener('mousedown',  forceFleeFromEvent);

    // Init
    layoutInitial();
    window.addEventListener('resize', () => layoutInitial());
    wrap.addEventListener('mousemove', onMouseMove);
  </script>
</body>
</html>
