<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine?</title>
  <style>
    :root {
      --bg: #fff5f7;
      --text: #111;
      --yes: #22c55e;
      --no:  #f43f5e;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      overflow: hidden;
    }
    .wrap {
      position: relative;
      width: 100vw;
      height: 100vh;
      user-select: none;
    }
    h1 {
      position: absolute;
      top: 42px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 28px;
      font-weight: 800;
      color: var(--text);
      text-align: center;
      white-space: nowrap;
      z-index: 5;
    }
    #result {
      position: absolute;
      bottom: 28px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 16px;
      color: var(--text);
      z-index: 5;
    }

    /* Capsule buttons */
    .btn {
      position: absolute;
      width: 140px;
      height: 56px;
      border: none;
      border-radius: 999px;
      color: #fff;
      font-weight: 800;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 1px 0 rgba(0,0,0,.15);
      transition: transform 60ms linear;
      will-change: transform, left, top, width, height;
      z-index: 6; /* above FX canvas */
    }
    .btn:active { filter: brightness(.9); transform: translateY(1px); }
    #yes { background: var(--yes); }
    #no  { background: var(--no);  }

    /* Keep hitbox aligned with visual size */
    .btn-inner {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
    }

    /* =========================
       Celebration (Yes click)
       ========================= */

    /* Canvas fireworks/confetti */
    #fx {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
    }

    /* Overlay */
    #celebrate {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: none;
      z-index: 10; /* above everything */
    }
    #celebrate.show { display: block; }

    /* Glass card message */
    #celebrate .card {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(.85);
      background: rgba(255,255,255,.78);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 22px;
      padding: 18px 26px;
      box-shadow: 0 18px 50px rgba(0,0,0,.16);
      text-align: center;
      animation: pop 520ms cubic-bezier(.2,1.2,.2,1) forwards;
    }
    #celebrate .title {
      font-size: 30px;
      font-weight: 900;
      letter-spacing: .2px;
      color: var(--text);
    }
    #celebrate .subtitle {
      margin-top: 6px;
      font-size: 14px;
      font-weight: 650;
      opacity: .75;
      color: var(--text);
    }
    @keyframes pop {
      0%   { transform: translate(-50%, -50%) scale(.70); opacity: 0; }
      65%  { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1.00); opacity: 1; }
    }

    /* Floating heart particles */
    .heart {
      position: absolute;
      will-change: transform, opacity;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.14));
      animation: floatUp 1400ms ease-out forwards;
      z-index: 11;
    }
    @keyframes floatUp {
      0%   { transform: translate(0,0) scale(.9); opacity: 0; }
      15%  { opacity: 1; }
      100% { transform: translate(var(--dx), var(--dy)) scale(1.35); opacity: 0; }
    }

    /* Cupid fly-by */
    #cupid {
      position: absolute;
      top: 22%;
      left: -90px;
      font-size: 52px;
      opacity: 0;
      transform: rotate(-8deg);
      z-index: 11;
    }
    #celebrate.fly #cupid {
      animation: fly 1400ms ease-in-out forwards;
    }
    @keyframes fly {
      0%   { left: -90px; opacity: 0; transform: rotate(-8deg) scale(.95); }
      10%  { opacity: 1; }
      60%  { opacity: 1; }
      100% { left: calc(100% + 90px); opacity: 0; transform: rotate(8deg) scale(1.05); }
    }
  </style>
</head>

<body>
  <div class="wrap" id="wrap">
    <h1>Will you be my valentine?</h1>

    <button class="btn" id="yes"><span class="btn-inner">Yes</span></button>
    <button class="btn" id="no"><span class="btn-inner">No</span></button>

    <!-- FX + overlay -->
    <canvas id="fx"></canvas>
    <div id="celebrate" aria-hidden="true">
      <div class="card">
        <div class="title">Yay! Luv u 2! ðŸ’–</div>
        <div class="subtitle">Happy Valentineâ€™s Day</div>
      </div>
      <div id="cupid">ðŸ’˜</div>
    </div>

    <div id="result">&nbsp;</div>
  </div>

  <script>
    const wrap = document.getElementById('wrap');
    const yesBtn = document.getElementById('yes');
    const noBtn  = document.getElementById('no');
    const result = document.getElementById('result');

    // Base sizes/positions
    const yesBase = { w: 140, h: 56 };
    const noBase  = { w: 140, h: 56 };

    // Scale constraints (match your Java logic)
    const YES_MAX = 1.30, YES_MIN = 1.00;
    const NO_MIN  = 0.70, NO_MAX  = 1.00;

    // Interaction tuning
    const TRIGGER_DIST = 160;    // px
    const TELEPORT_DIST = 5;     // px to rect edge
    const wallZone = 120;

    // Motion
    let noVX = 0, noVY = 0;
    let lastTeleport = 0;

    // Positions (top-left)
    let yesBasePos = null; // {x,y}
    let noPos = null;      // current no button {x,y}
    let noScale = 1.0;
    let yesScale = 1.0;

    // Helpers
    const clamp = (v, mn, mx) => Math.max(mn, Math.min(mx, v));
    const hypot = (a,b) => Math.hypot(a,b);

    function layoutInitial() {
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      const centerY = Math.floor(h * 0.55);

      yesBasePos = { x: Math.floor(w/2 - 170), y: Math.floor(centerY - yesBase.h/2) };
      const noBasePos = { x: Math.floor(w/2 + 30), y: Math.floor(centerY - noBase.h/2) };

      noPos = { x: noBasePos.x, y: noBasePos.y };

      applyButton(yesBtn, yesBasePos.x, yesBasePos.y, yesBase, 1.0, true);
      applyButton(noBtn,  noPos.x,      noPos.y,      noBase,  1.0, false);
    }

    function applyButton(el, x, y, base, scale, anchorCenter) {
      const w = Math.round(base.w * scale);
      const h = Math.round(base.h * scale);

      if (anchorCenter) {
        const baseCx = x + base.w / 2;
        const baseCy = y + base.h / 2;
        x = Math.round(baseCx - w / 2);
        y = Math.round(baseCy - h / 2);
      }

      el.style.left = x + 'px';
      el.style.top  = y + 'px';
      el.style.width  = w + 'px';
      el.style.height = h + 'px';
      return { w, h, x, y };
    }

    function rectOf(x, y, w, h) {
      return { x, y, w, h, cx: x + w/2, cy: y + h/2 };
    }

    function distanceToRect(px, py, r) {
      let dx = 0;
      if (px < r.x) dx = r.x - px;
      else if (px > r.x + r.w) dx = px - (r.x + r.w);

      let dy = 0;
      if (py < r.y) dy = r.y - py;
      else if (py > r.y + r.h) dy = py - (r.y + r.h);

      return Math.hypot(dx, dy);
    }

    function computeBoundsForNo(scaledNoW, scaledNoH) {
      const margin = 14;
      const topLimit = 90;
      const bottomLimit = wrap.clientHeight - 90;

      const minX = margin;
      const maxX = wrap.clientWidth - margin - scaledNoW;
      const minY = topLimit;
      const maxY = bottomLimit - scaledNoH;

      return { minX, maxX, minY, maxY, ok: (maxX > minX && maxY > minY) };
    }

    function teleportNo(mouseX, mouseY, scaledNoW, scaledNoH, bounds, currentRect) {
      const now = performance.now();
      if (now - lastTeleport < 0) return;
      lastTeleport = now;

      let bestScore = -1e18;
      let bestX = currentRect.x, bestY = currentRect.y;

      const tries = 18;
      for (let i = 0; i < tries; i++) {
        const rx = bounds.minX + Math.random() * (bounds.maxX - bounds.minX);
        const ry = bounds.minY + Math.random() * (bounds.maxY - bounds.minY);

        const candCX = rx + scaledNoW / 2;
        const candCY = ry + scaledNoH / 2;
        const d = hypot(mouseX - candCX, mouseY - candCY);

        const wall = Math.min(
          Math.min(rx - bounds.minX, bounds.maxX - rx),
          Math.min(ry - bounds.minY, bounds.maxY - ry)
        );

        const score = d + wall * 0.35;
        if (score > bestScore) {
          bestScore = score;
          bestX = rx;
          bestY = ry;
        }
      }

      noVX = 0; noVY = 0;
      noPos.x = bestX;
      noPos.y = bestY;
      applyButton(noBtn, noPos.x, noPos.y, noBase, noScale, false);
    }

    function onMouseMove(e) {
      if (!yesBasePos || !noPos) return;

      const mouseX = e.clientX;
      const mouseY = e.clientY;

      // Current No rect (based on DOM computed size)
      const noRectDOM = noBtn.getBoundingClientRect();
      const wrapRect = wrap.getBoundingClientRect();

      const noRect = rectOf(
        noRectDOM.left - wrapRect.left,
        noRectDOM.top  - wrapRect.top,
        noRectDOM.width,
        noRectDOM.height
      );

      const dx = mouseX - (noRect.cx + wrapRect.left);
      const dy = mouseY - (noRect.cy + wrapRect.top);
      const distCenter = Math.hypot(dx, dy);

      // Scaling
      yesScale = 1.0;
      noScale = 1.0;

      if (distCenter < TRIGGER_DIST) {
        const t = (TRIGGER_DIST - distCenter) / TRIGGER_DIST; // 0..1
        yesScale = clamp(YES_MIN + (YES_MAX - YES_MIN) * t, YES_MIN, YES_MAX);
        noScale  = clamp(NO_MAX  - (NO_MAX  - NO_MIN)  * t, NO_MIN,  NO_MAX);
      }

      // Apply Yes scaling (center anchored around base)
      applyButton(yesBtn, yesBasePos.x, yesBasePos.y, yesBase, yesScale, true);

      // Apply No scaling and movement
      const scaledNoW = Math.round(noBase.w * noScale);
      const scaledNoH = Math.round(noBase.h * noScale);

      const bounds = computeBoundsForNo(scaledNoW, scaledNoH);
      if (!bounds.ok) return;

      // Teleport if mouse is within TELEPORT_DIST of the No button edge
      const edgeDist = distanceToRect(mouseX - wrapRect.left, mouseY - wrapRect.top, {
        x: noRect.x, y: noRect.y, w: noRect.w, h: noRect.h
      });

      if (edgeDist <= TELEPORT_DIST) {
        teleportNo(mouseX - wrapRect.left, mouseY - wrapRect.top, scaledNoW, scaledNoH, bounds, noRect);
        return;
      }

      // Smooth flee with wall repulsion
      let ax = 0, ay = 0;

      if (distCenter < TRIGGER_DIST) {
        const t = (TRIGGER_DIST - distCenter) / TRIGGER_DIST;
        const d = distCenter === 0 ? 1 : distCenter;
        const ux = dx / d, uy = dy / d;

        const mouseAccel = 2.2 + 6.5 * t;

        // Perpendicular unit vector (rotated 90Â°)
        const px = -uy;
        const py =  ux;

        // Side-step amount increases when closer
        const strafe = 0.8 + 2.5 * t;

        // Flip direction sometimes for unpredictability
        const jitter = (Math.random() < 0.08 ? -1 : 1);

        ax += (-ux * mouseAccel) + (px * strafe * jitter);
        ay += (-uy * mouseAccel) + (py * strafe * jitter);
      }

      // Wall repulsion
      const x = noRect.x;
      const y = noRect.y;

      const dLeft   = x - bounds.minX;
      const dRight  = bounds.maxX - x;
      const dTop    = y - bounds.minY;
      const dBottom = bounds.maxY - y;

      if (dLeft   < wallZone) ax += (wallZone - dLeft)   / wallZone * 4.5;
      if (dRight  < wallZone) ax -= (wallZone - dRight)  / wallZone * 4.5;
      if (dTop    < wallZone) ay += (wallZone - dTop)    / wallZone * 4.5;
      if (dBottom < wallZone) ay -= (wallZone - dBottom) / wallZone * 4.5;

      // Velocity + damping
      const damping = 0.92;
      const maxSpeed = 32.0;

      noVX = (noVX + ax) * damping;
      noVY = (noVY + ay) * damping;

      const speed = Math.hypot(noVX, noVY);
      if (speed > maxSpeed) {
        noVX = noVX / speed * maxSpeed;
        noVY = noVY / speed * maxSpeed;
      }

      let nx = x + noVX;
      let ny = y + noVY;

      // Clamp + mild bounce
      if (nx < bounds.minX) { nx = bounds.minX; noVX = Math.abs(noVX) * 0.5; }
      if (nx > bounds.maxX) { nx = bounds.maxX; noVX = -Math.abs(noVX) * 0.5; }
      if (ny < bounds.minY) { ny = bounds.minY; noVY = Math.abs(noVY) * 0.5; }
      if (ny > bounds.maxY) { ny = bounds.maxY; noVY = -Math.abs(noVY) * 0.5; }

      // Set new position
      noPos.x = nx;
      noPos.y = ny;

      applyButton(noBtn, noPos.x, noPos.y, noBase, noScale, false);

      // Settle when far
      if (distCenter >= TRIGGER_DIST) {
        noVX *= 0.90;
        noVY *= 0.90;
      }
    }

    // Make No react if mouse enters/presses it (extra safety like your Java code)
    function forceFleeFromEvent(ev) {
      if (ev && typeof ev.clientX === 'number') onMouseMove(ev);
    }
    noBtn.addEventListener('mouseenter', forceFleeFromEvent);
    noBtn.addEventListener('mousedown',  forceFleeFromEvent);

    // Init
    layoutInitial();
    window.addEventListener('resize', () => layoutInitial());
    wrap.addEventListener('mousemove', onMouseMove);

    /* =========================
       Celebration FX (Yes click)
       ========================= */

    const fx = document.getElementById('fx');
    const fxCtx = fx.getContext('2d', { alpha: true });
    const celebrate = document.getElementById('celebrate');

    function resizeFX() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      fx.width  = Math.floor(wrap.clientWidth * dpr);
      fx.height = Math.floor(wrap.clientHeight * dpr);
      fx.style.width  = wrap.clientWidth + 'px';
      fx.style.height = wrap.clientHeight + 'px';
      fxCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeFX();
    window.addEventListener('resize', resizeFX);

    let particles = [];
    let raf = null;

    function burst(x, y, count = 120) {
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const s = 2 + Math.random() * 7;
        particles.push({
          x, y,
          vx: Math.cos(a) * s,
          vy: Math.sin(a) * s - 2.0,
          life: 60 + Math.random() * 25,
          r: 2 + Math.random() * 2.5,
          drag: 0.985,
          hue: Math.random() * 360
        });
      }
    }

    function stepFX() {
      fxCtx.clearRect(0, 0, wrap.clientWidth, wrap.clientHeight);

      // subtle trail
      fxCtx.fillStyle = 'rgba(255,245,247,0.12)';
      fxCtx.fillRect(0, 0, wrap.clientWidth, wrap.clientHeight);

      particles = particles.filter(p => p.life > 0);

      for (const p of particles) {
        p.life--;
        p.vx *= p.drag;
        p.vy = p.vy * p.drag + 0.14; // gravity
        p.x += p.vx;
        p.y += p.vy;

        fxCtx.beginPath();
        fxCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        fxCtx.fillStyle = `hsla(${p.hue}, 90%, 60%, ${Math.min(1, p.life / 35)})`;
        fxCtx.fill();
      }

      if (particles.length > 0) {
        raf = requestAnimationFrame(stepFX);
      } else {
        fxCtx.clearRect(0, 0, wrap.clientWidth, wrap.clientHeight);
        raf = null;
      }
    }

    function spawnHearts(n = 26) {
      for (let i = 0; i < n; i++) {
        const h = document.createElement('div');
        h.className = 'heart';
        h.textContent = Math.random() < 0.5 ? 'ðŸ’–' : 'ðŸ’˜';

        const x = wrap.clientWidth / 2 + (Math.random() * 220 - 110);
        const y = wrap.clientHeight / 2 + (Math.random() * 90 - 45);
        h.style.left = x + 'px';
        h.style.top  = y + 'px';
        h.style.setProperty('--dx', (Math.random() * 300 - 150) + 'px');
        h.style.setProperty('--dy', (-260 - Math.random() * 260) + 'px');
        h.style.fontSize = (16 + Math.random() * 20) + 'px';

        wrap.appendChild(h);
        h.addEventListener('animationend', () => h.remove());
      }
    }

    function celebrateYes() {
      result.textContent = 'Yay! Luv u 2!';

      // show overlay + restart cupid animation
      celebrate.classList.add('show');
      celebrate.classList.remove('fly');
      void celebrate.offsetWidth; // force reflow
      celebrate.classList.add('fly');

      // bursts + hearts
      const cx = wrap.clientWidth / 2;
      const cy = wrap.clientHeight / 2;
      burst(cx, cy, 140);
      burst(cx - 240, cy + 40, 110);
      burst(cx + 240, cy + 40, 110);
      spawnHearts(30);

      if (!raf) stepFX();

      // hide overlay after a moment
      setTimeout(() => {
        celebrate.classList.remove('show');
      }, 2200);
    }

    // Click behavior (updated Yes)
    yesBtn.addEventListener('click', celebrateYes);
    noBtn.addActionListener?.(() => {}); // no-op if someone pastes into a JS environment with extensions

    noBtn.addEventListener('click', () => result.textContent = 'Noooooo how did u click it :(');
  </script>
</body>
</html>
